{
    "docs": [
        {
            "location": "/",
            "text": "zend-escaper\n\n\n\n\n\n\nThe OWASP Top 10 web security risks study lists Cross-Site Scripting (XSS) in\nsecond place. PHP\u2019s sole functionality against XSS is limited to two functions\nof which one is commonly misapplied. Thus, the zend-escaper component was written.\nIt offers developers a way to escape output and defend from XSS and related\nvulnerabilities by introducing contextual escaping based on peer-reviewed rules.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-escaper/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-escaper/",
            "title": "zend-escaper"
        },
        {
            "location": "/#zend-escaper",
            "text": "The OWASP Top 10 web security risks study lists Cross-Site Scripting (XSS) in\nsecond place. PHP\u2019s sole functionality against XSS is limited to two functions\nof which one is commonly misapplied. Thus, the zend-escaper component was written.\nIt offers developers a way to escape output and defend from XSS and related\nvulnerabilities by introducing contextual escaping based on peer-reviewed rules.   File issues at https://github.com/zendframework/zend-escaper/issues  Documentation is at https://docs.zendframework.com/zend-escaper/",
            "title": "zend-escaper"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nThe \nOWASP Top 10 web security risks\n\nstudy lists Cross-Site Scripting (XSS) in second place. PHP's sole functionality\nagainst XSS is limited to two functions of which one is commonly misapplied.\nThus, the zend-escaper component was written. It offers developers a way to\nescape output and defend from XSS and related vulnerabilities by introducing\n\ncontextual escaping based on peer-reviewed rules\n.\n\n\nzend-escaper was written with ease of use in mind, so it can be used completely stand-alone from\nthe rest of the framework, and as such can be installed with Composer:\n\n\n$ composer require zendframework/zend-escaper\n\n\n\nSeveral Zend Framework components provide integrations for consuming\nzend-escaper, including \nzend-view\n,\nwhich provides a set of helpers that consume it.\n\n\n\n\nSecurity\n\n\nzend-escaper is a security related component. As such, if you believe you have\nfound an issue, we ask that you follow our \nSecurity  Policy\n\nand report security issues accordingly. The Zend Framework team and the\ncontributors thank you in advance.\n\n\n\n\nOverview\n\n\nzend-escaper provides one class, \nZend\\Escaper\\Escaper\n, which in turn provides\nfive methods for escaping output. Which method to use  depends on the context in\nwhich the output is used. It is up to the developer to use the right methods in\nthe right context.\n\n\nZend\\Escaper\\Escaper\n has the following escaping methods available for each context:\n\n\n\n\nescapeHtml\n: escape a string for an HTML body context.\n\n\nescapeHtmlAttr\n: escape a string for an HTML attribute context.\n\n\nescapeJs\n: escape a string for a Javascript context.\n\n\nescapeCss\n: escape a string for a CSS context.\n\n\nescapeUrl\n: escape a string for a URI or URI parameter context.\n\n\n\n\nUsage of each method will be discussed in detail in later chapters.\n\n\nWhat zend-Escaper is not\n\n\nzend-escaper is meant to be used only for \nescaping data for output\n, and as\nsuch should not be misused for \nfiltering input data\n. For such tasks, use\n\nzend-filter\n,\n\nHTMLPurifier\n or PHP's\n\nFilter\n functionality should be used.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "The  OWASP Top 10 web security risks \nstudy lists Cross-Site Scripting (XSS) in second place. PHP's sole functionality\nagainst XSS is limited to two functions of which one is commonly misapplied.\nThus, the zend-escaper component was written. It offers developers a way to\nescape output and defend from XSS and related vulnerabilities by introducing contextual escaping based on peer-reviewed rules .  zend-escaper was written with ease of use in mind, so it can be used completely stand-alone from\nthe rest of the framework, and as such can be installed with Composer:  $ composer require zendframework/zend-escaper  Several Zend Framework components provide integrations for consuming\nzend-escaper, including  zend-view ,\nwhich provides a set of helpers that consume it.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#security",
            "text": "zend-escaper is a security related component. As such, if you believe you have\nfound an issue, we ask that you follow our  Security  Policy \nand report security issues accordingly. The Zend Framework team and the\ncontributors thank you in advance.",
            "title": "Security"
        },
        {
            "location": "/intro/#overview",
            "text": "zend-escaper provides one class,  Zend\\Escaper\\Escaper , which in turn provides\nfive methods for escaping output. Which method to use  depends on the context in\nwhich the output is used. It is up to the developer to use the right methods in\nthe right context.  Zend\\Escaper\\Escaper  has the following escaping methods available for each context:   escapeHtml : escape a string for an HTML body context.  escapeHtmlAttr : escape a string for an HTML attribute context.  escapeJs : escape a string for a Javascript context.  escapeCss : escape a string for a CSS context.  escapeUrl : escape a string for a URI or URI parameter context.   Usage of each method will be discussed in detail in later chapters.",
            "title": "Overview"
        },
        {
            "location": "/intro/#what-zend-escaper-is-not",
            "text": "zend-escaper is meant to be used only for  escaping data for output , and as\nsuch should not be misused for  filtering input data . For such tasks, use zend-filter , HTMLPurifier  or PHP's Filter  functionality should be used.",
            "title": "What zend-Escaper is not"
        },
        {
            "location": "/theory-of-operation/",
            "text": "Theory of Operation\n\n\nzend-escaper provides methods for escaping output data, dependent on the context\nin which the data will be used. Each method is based on peer-reviewed rules and\nis in compliance with the current OWASP recommendations.\n\n\nThe escaping follows a well-known and fixed set of encoding rules defined by\nOWASP for each key HTML context.  These rules cannot be impacted or negated by\nbrowser quirks or edge-case HTML parsing unless the browser suffers a\ncatastrophic bug in its HTML parser or Javascript interpreter \u2014 both of\nthese are unlikely.\n\n\nThe contexts in which zend-escaper should be used are \nHTML Body\n, \nHTML\nAttribute\n, \nJavascript\n, \nCSS\n, and \nURL/URI\n contexts.\n\n\nEvery escaper method will take the data to be escaped, make sure it is utf-8\nencoded data (or try to convert it to utf-8), perform context-based escaping,\nencode the escaped data back to its original encoding, and return the data to\nthe caller.\n\n\nThe actual escaping of the data differs between each method; they all have their\nown set of rules according to which escaping is performed. An example will allow\nus to clearly demonstrate the difference, and how the same characters are being\nescaped differently between contexts:\n\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// &lt;script&gt;alert(&quot;zf2&quot;)&lt;/script&gt;\necho $escaper->escapeHtml('<script>alert(\"zf2\")</script>');\n\n// &lt;script&gt;alert&#x28;&quot;zf2&quot;&#x29;&lt;&#x2F;script&gt;\necho $escaper->escapeHtmlAttr('<script>alert(\"zf2\")</script>');\n\n// \\x3Cscript\\x3Ealert\\x28\\x22zf2\\x22\\x29\\x3C\\x2Fscript\\x3E\necho $escaper->escapeJs('<script>alert(\"zf2\")</script>');\n\n// \\3C script\\3E alert\\28 \\22 zf2\\22 \\29 \\3C \\2F script\\3E\necho $escaper->escapeCss('<script>alert(\"zf2\")</script>');\n\n// %3Cscript%3Ealert%28%22zf2%22%29%3C%2Fscript%3E\necho $escaper->escapeUrl('<script>alert(\"zf2\")</script>');\n\n\n\nMore detailed examples will be given in later chapters.\n\n\nThe Problem with Inconsistent Functionality\n\n\nAt present, programmers orient towards the following PHP functions for each\ncommon HTML context:\n\n\n\n\nHTML Body\n: \nhtmlspecialchars()\n or \nhtmlentities()\n\n\nHTML Attribute\n: \nhtmlspecialchars()\n or \nhtmlentities()\n\n\nJavascript\n: \naddslashes()\n or \njson_encode()\n\n\nCSS\n: n/a\n\n\nURL/URI\n: \nrawurlencode()\n or \nurlencode()\n\n\n\n\nIn practice, these decisions appear to depend more on what PHP offers, and if it\ncan be interpreted as offering sufficient escaping safety, than it does on what\nis recommended in reality to defend against XSS. While these functions can\nprevent some forms of XSS, they do not cover all use cases or risks and are\ntherefore insufficient defenses.\n\n\nUsing \nhtmlspecialchars()\n in a perfectly valid HTML5 unquoted attribute value,\nfor example, is completely useless since the value can be terminated by a space\n(among other things), which is never escaped. Thus, in this instance, we have a\nconflict between a widely used HTML escaper and a modern HTML specification,\nwith no specific function available to cover this use case. While it's tempting\nto blame users, or the HTML specification authors, escaping just needs to deal\nwith whatever HTML and browsers allow.\n\n\nUsing \naddslashes()\n, custom backslash escaping, or \njson_encode()\n will\ntypically ignore HTML special characters such as ampersands, which may be used\nto inject entities into Javascript. Under the right circumstances, the browser\nwill convert these entities into their literal equivalents before interpreting\nJavascript, thus allowing attackers to inject arbitrary code.\n\n\nInconsistencies with valid HTML, insecure default parameters, lack of character\nencoding awareness, and misrepresentations of what functions are capable of by\nsome programmers \u2014 these all make escaping in PHP an unnecessarily\nconvoluted quest.\n\n\nTo circumvent the lack of escaping methods in PHP, zend-escaper addresses the\nneed to apply context-specific escaping in web applications. It implements\nmethods that specifically target XSS and offers programmers a tool to secure\ntheir applications without misusing other inadequate methods, or using, most\nlikely incomplete, home-grown solutions.\n\n\nWhy Contextual Escaping?\n\n\nTo understand why multiple standardised escaping methods are needed, what\nfollows are several quick points; they are by no means a complete set of\nreasons, however!\n\n\nHTML escaping of unquoted HTML attribute values still allows XSS\n\n\nThis is probably the best known way to defeat \nhtmlspecialchars()\n when used on\nattribute values, since any space (or character interpreted as a space \u2014\nthere are a lot) lets you inject new attributes whose content can't be\nneutralised by HTML escaping. The solution (where this is possible) is\nadditional escaping as defined by the OWASP ESAPI codecs. The point here can be\nextended further \u2014 escaping only works if a programmer or designer knows\nwhat they're doing. In many contexts, there are additional practices and gotchas\nthat need to be carefully monitored since escaping sometimes needs a little\nextra help to protect against XSS \u2014 even if that means ensuring all\nattribute values are properly double quoted despite this not being required for\nvalid HTML.\n\n\nHTML escaping of CSS, Javascript or URIs is often reversed when passed to non-HTML interpreters by the browser\n\n\nHTML escaping is just that &mdsash; it's designed to escape a string for HTML\n(i.e. prevent tag or attribute insertion), but not alter the underlying meaning\nof the content, whether it be text, Javascript, CSS, or URIs. For that purpose,\na fully HTML-escaped version of any other context may still have its unescaped\nform extracted before it's interpreted or executed. For this reason we need\nseparate escapers for Javascript, CSS, and URIs, and developers or designers\nwriting templates \nmust\n know which escaper to apply to which context. Of\ncourse, this means you need to be able to identify the correct context before\nselecting the right escaper!\n\n\nDOM-based XSS requires a defence using at least two levels of different escaping in many cases\n\n\nDOM-based XSS has become increasingly common as Javascript has taken off in\npopularity for large scale client-side coding. A simple example is Javascript\ndefined in a template which inserts a new piece of HTML text into the DOM. If\nthe string is only HTML escaped, it may still contain Javascript that will\nexecute in that context. If the string is only Javascript-escaped, it may\ncontain HTML markup (new tags and attributes) which will be injected into the\nDOM and parsed once the inserting Javascript executes. Damned either way? The\nsolution is to escape twice \u2014 first escape the string for HTML (make it\nsafe for DOM insertion), and then for Javascript (make it safe for the current\nJavascript context). Nested contexts are a common means of bypassing naive\nescaping habits (e.g. you can inject Javascript into a CSS expression within an\nHTML attribute).\n\n\nPHP has no known anti-XSS escape functions (only those kidnapped from their original purposes)\n\n\nA simple example, widely used, is when you see \njson_encode()\n used to escape\nJavascript, or worse, some kind of mutant \naddslashes()\n implementation. These\nwere never designed to eliminate XSS, yet PHP programmers use them as such. For\nexample, \njson_encode()\n does not escape the ampersand or semi-colon characters\nby default. That means you can easily inject HTML entities which could then be\ndecoded before the Javascript is evaluated in a HTML document. This lets you\nbreak out of strings, add new JS statements, close tags, etc. In other words,\nusing \njson_encode()\n is insufficient and naive. The same, arguably, could be\nsaid for \nhtmlspecialchars()\n which has its own well known limitations that make\na singular reliance on it a questionable practice.",
            "title": "Theory of Operation"
        },
        {
            "location": "/theory-of-operation/#theory-of-operation",
            "text": "zend-escaper provides methods for escaping output data, dependent on the context\nin which the data will be used. Each method is based on peer-reviewed rules and\nis in compliance with the current OWASP recommendations.  The escaping follows a well-known and fixed set of encoding rules defined by\nOWASP for each key HTML context.  These rules cannot be impacted or negated by\nbrowser quirks or edge-case HTML parsing unless the browser suffers a\ncatastrophic bug in its HTML parser or Javascript interpreter \u2014 both of\nthese are unlikely.  The contexts in which zend-escaper should be used are  HTML Body ,  HTML\nAttribute ,  Javascript ,  CSS , and  URL/URI  contexts.  Every escaper method will take the data to be escaped, make sure it is utf-8\nencoded data (or try to convert it to utf-8), perform context-based escaping,\nencode the escaped data back to its original encoding, and return the data to\nthe caller.  The actual escaping of the data differs between each method; they all have their\nown set of rules according to which escaping is performed. An example will allow\nus to clearly demonstrate the difference, and how the same characters are being\nescaped differently between contexts:  $escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// &lt;script&gt;alert(&quot;zf2&quot;)&lt;/script&gt;\necho $escaper->escapeHtml('<script>alert(\"zf2\")</script>');\n\n// &lt;script&gt;alert&#x28;&quot;zf2&quot;&#x29;&lt;&#x2F;script&gt;\necho $escaper->escapeHtmlAttr('<script>alert(\"zf2\")</script>');\n\n// \\x3Cscript\\x3Ealert\\x28\\x22zf2\\x22\\x29\\x3C\\x2Fscript\\x3E\necho $escaper->escapeJs('<script>alert(\"zf2\")</script>');\n\n// \\3C script\\3E alert\\28 \\22 zf2\\22 \\29 \\3C \\2F script\\3E\necho $escaper->escapeCss('<script>alert(\"zf2\")</script>');\n\n// %3Cscript%3Ealert%28%22zf2%22%29%3C%2Fscript%3E\necho $escaper->escapeUrl('<script>alert(\"zf2\")</script>');  More detailed examples will be given in later chapters.",
            "title": "Theory of Operation"
        },
        {
            "location": "/theory-of-operation/#the-problem-with-inconsistent-functionality",
            "text": "At present, programmers orient towards the following PHP functions for each\ncommon HTML context:   HTML Body :  htmlspecialchars()  or  htmlentities()  HTML Attribute :  htmlspecialchars()  or  htmlentities()  Javascript :  addslashes()  or  json_encode()  CSS : n/a  URL/URI :  rawurlencode()  or  urlencode()   In practice, these decisions appear to depend more on what PHP offers, and if it\ncan be interpreted as offering sufficient escaping safety, than it does on what\nis recommended in reality to defend against XSS. While these functions can\nprevent some forms of XSS, they do not cover all use cases or risks and are\ntherefore insufficient defenses.  Using  htmlspecialchars()  in a perfectly valid HTML5 unquoted attribute value,\nfor example, is completely useless since the value can be terminated by a space\n(among other things), which is never escaped. Thus, in this instance, we have a\nconflict between a widely used HTML escaper and a modern HTML specification,\nwith no specific function available to cover this use case. While it's tempting\nto blame users, or the HTML specification authors, escaping just needs to deal\nwith whatever HTML and browsers allow.  Using  addslashes() , custom backslash escaping, or  json_encode()  will\ntypically ignore HTML special characters such as ampersands, which may be used\nto inject entities into Javascript. Under the right circumstances, the browser\nwill convert these entities into their literal equivalents before interpreting\nJavascript, thus allowing attackers to inject arbitrary code.  Inconsistencies with valid HTML, insecure default parameters, lack of character\nencoding awareness, and misrepresentations of what functions are capable of by\nsome programmers \u2014 these all make escaping in PHP an unnecessarily\nconvoluted quest.  To circumvent the lack of escaping methods in PHP, zend-escaper addresses the\nneed to apply context-specific escaping in web applications. It implements\nmethods that specifically target XSS and offers programmers a tool to secure\ntheir applications without misusing other inadequate methods, or using, most\nlikely incomplete, home-grown solutions.",
            "title": "The Problem with Inconsistent Functionality"
        },
        {
            "location": "/theory-of-operation/#why-contextual-escaping",
            "text": "To understand why multiple standardised escaping methods are needed, what\nfollows are several quick points; they are by no means a complete set of\nreasons, however!",
            "title": "Why Contextual Escaping?"
        },
        {
            "location": "/theory-of-operation/#html-escaping-of-unquoted-html-attribute-values-still-allows-xss",
            "text": "This is probably the best known way to defeat  htmlspecialchars()  when used on\nattribute values, since any space (or character interpreted as a space \u2014\nthere are a lot) lets you inject new attributes whose content can't be\nneutralised by HTML escaping. The solution (where this is possible) is\nadditional escaping as defined by the OWASP ESAPI codecs. The point here can be\nextended further \u2014 escaping only works if a programmer or designer knows\nwhat they're doing. In many contexts, there are additional practices and gotchas\nthat need to be carefully monitored since escaping sometimes needs a little\nextra help to protect against XSS \u2014 even if that means ensuring all\nattribute values are properly double quoted despite this not being required for\nvalid HTML.",
            "title": "HTML escaping of unquoted HTML attribute values still allows XSS"
        },
        {
            "location": "/theory-of-operation/#html-escaping-of-css-javascript-or-uris-is-often-reversed-when-passed-to-non-html-interpreters-by-the-browser",
            "text": "HTML escaping is just that &mdsash; it's designed to escape a string for HTML\n(i.e. prevent tag or attribute insertion), but not alter the underlying meaning\nof the content, whether it be text, Javascript, CSS, or URIs. For that purpose,\na fully HTML-escaped version of any other context may still have its unescaped\nform extracted before it's interpreted or executed. For this reason we need\nseparate escapers for Javascript, CSS, and URIs, and developers or designers\nwriting templates  must  know which escaper to apply to which context. Of\ncourse, this means you need to be able to identify the correct context before\nselecting the right escaper!",
            "title": "HTML escaping of CSS, Javascript or URIs is often reversed when passed to non-HTML interpreters by the browser"
        },
        {
            "location": "/theory-of-operation/#dom-based-xss-requires-a-defence-using-at-least-two-levels-of-different-escaping-in-many-cases",
            "text": "DOM-based XSS has become increasingly common as Javascript has taken off in\npopularity for large scale client-side coding. A simple example is Javascript\ndefined in a template which inserts a new piece of HTML text into the DOM. If\nthe string is only HTML escaped, it may still contain Javascript that will\nexecute in that context. If the string is only Javascript-escaped, it may\ncontain HTML markup (new tags and attributes) which will be injected into the\nDOM and parsed once the inserting Javascript executes. Damned either way? The\nsolution is to escape twice \u2014 first escape the string for HTML (make it\nsafe for DOM insertion), and then for Javascript (make it safe for the current\nJavascript context). Nested contexts are a common means of bypassing naive\nescaping habits (e.g. you can inject Javascript into a CSS expression within an\nHTML attribute).",
            "title": "DOM-based XSS requires a defence using at least two levels of different escaping in many cases"
        },
        {
            "location": "/theory-of-operation/#php-has-no-known-anti-xss-escape-functions-only-those-kidnapped-from-their-original-purposes",
            "text": "A simple example, widely used, is when you see  json_encode()  used to escape\nJavascript, or worse, some kind of mutant  addslashes()  implementation. These\nwere never designed to eliminate XSS, yet PHP programmers use them as such. For\nexample,  json_encode()  does not escape the ampersand or semi-colon characters\nby default. That means you can easily inject HTML entities which could then be\ndecoded before the Javascript is evaluated in a HTML document. This lets you\nbreak out of strings, add new JS statements, close tags, etc. In other words,\nusing  json_encode()  is insufficient and naive. The same, arguably, could be\nsaid for  htmlspecialchars()  which has its own well known limitations that make\na singular reliance on it a questionable practice.",
            "title": "PHP has no known anti-XSS escape functions (only those kidnapped from their original purposes)"
        },
        {
            "location": "/configuration/",
            "text": "Configuration\n\n\nZend\\Escaper\\Escaper\n has only one configuration option available, and that is\nthe encoding to be used by the \nEscaper\n instance.\n\n\nThe default encoding is \nutf-8\n. Other supported encodings are:\n\n\n\n\niso-8859-1\n\n\niso-8859-5\n\n\niso-8859-15\n\n\ncp866, ibm866, 866\n\n\ncp1251, windows-1251\n\n\ncp1252, windows-1252\n\n\nkoi8-r, koi8-ru\n\n\nbig5, big5-hkscs, 950, gb2312, 936\n\n\nshift_jis, sjis, sjis-win, cp932\n\n\neucjp, eucjp-win\n\n\nmacroman\n\n\n\n\nIf an unsupported encoding is passed to \nZend\\Escaper\\Escaper\n, a\n\nZend\\Escaper\\Exception\\InvalidArgumentException\n will be thrown.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/#configuration",
            "text": "Zend\\Escaper\\Escaper  has only one configuration option available, and that is\nthe encoding to be used by the  Escaper  instance.  The default encoding is  utf-8 . Other supported encodings are:   iso-8859-1  iso-8859-5  iso-8859-15  cp866, ibm866, 866  cp1251, windows-1251  cp1252, windows-1252  koi8-r, koi8-ru  big5, big5-hkscs, 950, gb2312, 936  shift_jis, sjis, sjis-win, cp932  eucjp, eucjp-win  macroman   If an unsupported encoding is passed to  Zend\\Escaper\\Escaper , a Zend\\Escaper\\Exception\\InvalidArgumentException  will be thrown.",
            "title": "Configuration"
        },
        {
            "location": "/escaping-html/",
            "text": "Escaping HTML\n\n\nProbably the most common escaping happens for \nHTML body\n contexts. There are\nvery few characters with special meaning in this context, yet it is quite common\nto escape data incorrectly, namely by setting the wrong flags and character\nencoding.\n\n\nFor escaping data to use within an HTML body context, use\n\nZend\\Escaper\\Escaper\n's \nescapeHtml()\n method.  Internally it uses PHP's\n\nhtmlspecialchars()\n, correctly setting the flags and encoding for you.\n\n\n// Outputting this without escaping would be a bad idea!\n$input = '<script>alert(\"zf2\")</script>';\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// somewhere in an HTML template\n<div class=\"user-provided-input\">\n    <?= $escaper->escapeHtml($input) // all safe! ?>\n</div>\n\n\n\nOne thing a developer needs to pay special attention to is the encoding in which\nthe document is served to the client, as it \nmust be the same\n as the encoding\nused for escaping!\n\n\nExample of Bad HTML Escaping\n\n\nAn example of incorrect usage:\n\n\n<?php\n$input = '<script>alert(\"zf2\")</script>';\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n?>\n<?php header('Content-Type: text/html; charset=ISO-8859-1'); ?>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Encodings set incorrectly!</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head>\n<body>\n<?php\n    // Bad! The escaper's and the document's encodings are different!\n    echo $escaper->escapeHtml($input);\n?>\n</body>\n\n\n\nExample of Good HTML Escaping\n\n\nAn example of correct usage:\n\n\n<?php\n$input = '<script>alert(\"zf2\")</script>';\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n?>\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Encodings set correctly!</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n<?php\n    // Good! The escaper's and the document's encodings are same!\n    echo $escaper->escapeHtml($input);\n?>\n</body>",
            "title": "Escaping HTML"
        },
        {
            "location": "/escaping-html/#escaping-html",
            "text": "Probably the most common escaping happens for  HTML body  contexts. There are\nvery few characters with special meaning in this context, yet it is quite common\nto escape data incorrectly, namely by setting the wrong flags and character\nencoding.  For escaping data to use within an HTML body context, use Zend\\Escaper\\Escaper 's  escapeHtml()  method.  Internally it uses PHP's htmlspecialchars() , correctly setting the flags and encoding for you.  // Outputting this without escaping would be a bad idea!\n$input = '<script>alert(\"zf2\")</script>';\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// somewhere in an HTML template\n<div class=\"user-provided-input\">\n    <?= $escaper->escapeHtml($input) // all safe! ?>\n</div>  One thing a developer needs to pay special attention to is the encoding in which\nthe document is served to the client, as it  must be the same  as the encoding\nused for escaping!",
            "title": "Escaping HTML"
        },
        {
            "location": "/escaping-html/#example-of-bad-html-escaping",
            "text": "An example of incorrect usage:  <?php\n$input = '<script>alert(\"zf2\")</script>';\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n?>\n<?php header('Content-Type: text/html; charset=ISO-8859-1'); ?>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Encodings set incorrectly!</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\">\n</head>\n<body>\n<?php\n    // Bad! The escaper's and the document's encodings are different!\n    echo $escaper->escapeHtml($input);\n?>\n</body>",
            "title": "Example of Bad HTML Escaping"
        },
        {
            "location": "/escaping-html/#example-of-good-html-escaping",
            "text": "An example of correct usage:  <?php\n$input = '<script>alert(\"zf2\")</script>';\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n?>\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Encodings set correctly!</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n<?php\n    // Good! The escaper's and the document's encodings are same!\n    echo $escaper->escapeHtml($input);\n?>\n</body>",
            "title": "Example of Good HTML Escaping"
        },
        {
            "location": "/escaping-html-attributes/",
            "text": "Escaping HTML Attributes\n\n\nEscaping data in \nHTML Attribute\n contexts is most often done incorrectly, if\nnot overlooked completely by developers. Regular \nHTML\nescaping\n can be used for escaping HTML attributes \nonly\n if\nthe attribute value can be \nguaranteed as being properly quoted\n! To avoid\nconfusion, we recommend always using the HTML Attribute escaper method when\ndealing with HTTP attributes specifically.\n\n\nTo escape data for an HTML Attribute, use \nZend\\Escaper\\Escaper\n's\n\nescapeHtmlAttr()\n method.  Internally it will convert the data to UTF-8, check\nfor its validity, and use an extended set of characters to escape that are not\ncovered by \nhtmlspecialchars()\n to cover the cases where an attribute might be\nunquoted or quoted illegally.\n\n\nExamples of Bad HTML Attribute Escaping\n\n\nAn example of incorrect HTML attribute escaping:\n\n\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n' onmouseover='alert(/ZF2!/);\nINPUT;\n\n/**\n * NOTE: This is equivalent to using htmlspecialchars($input, ENT_COMPAT)\n */\n$output = htmlspecialchars($input);\n?>\n<html>\n<head>\n    <title>Single Quoted Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title='' onmouseover='alert(/ZF2!/);'>\n        ?>\n        <span title='<?= $output ?>'>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>\n\n\n\nIn the above example, the default \nENT_COMPAT\n flag is being used, which does\nnot escape single quotes, thus resulting in an alert box popping up when the\n\nonmouseover\n event happens on the \nspan\n element.\n\n\nAnother example of incorrect HTML attribute escaping can happen when unquoted\nattributes are used (which is, by the way, perfectly valid HTML5):\n\n\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nfaketitle onmouseover=alert(/ZF2!/);\nINPUT;\n\n// Tough luck using proper flags when the title attribute is unquoted!\n$output = htmlspecialchars($input, ENT_QUOTES);\n?>\n<html>\n<head>\n    <title>Quoteless Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title=faketitle onmouseover=alert(/ZF2!/);>\n        ?>\n        <span title=<?= $output ?>>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>\n\n\n\nThe above example shows how it is easy to break out from unquoted attributes in\nHTML5.\n\n\nExample of Good HTML Attribute Escaping\n\n\nBoth of the previous examples can be avoided by simply using the\n\nescapeHtmlAttr()\n method:\n\n\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nfaketitle onmouseover=alert(/ZF2!/);\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeHtmlAttr($input);\n?>\n<html>\n<head>\n    <title>Quoteless Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title=faketitle&#x20;onmouseover&#x3D;alert&#x28;&#x2F;ZF2&#x21;&#x2F;&#x29;&#x3B;>\n        ?>\n        <span title=<?= $output ?>>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>\n\n\n\nIn the above example, the malicious input from the attacker becomes completely\nharmless as we used proper HTML attribute escaping!",
            "title": "Escaping HTML Attributes"
        },
        {
            "location": "/escaping-html-attributes/#escaping-html-attributes",
            "text": "Escaping data in  HTML Attribute  contexts is most often done incorrectly, if\nnot overlooked completely by developers. Regular  HTML\nescaping  can be used for escaping HTML attributes  only  if\nthe attribute value can be  guaranteed as being properly quoted ! To avoid\nconfusion, we recommend always using the HTML Attribute escaper method when\ndealing with HTTP attributes specifically.  To escape data for an HTML Attribute, use  Zend\\Escaper\\Escaper 's escapeHtmlAttr()  method.  Internally it will convert the data to UTF-8, check\nfor its validity, and use an extended set of characters to escape that are not\ncovered by  htmlspecialchars()  to cover the cases where an attribute might be\nunquoted or quoted illegally.",
            "title": "Escaping HTML Attributes"
        },
        {
            "location": "/escaping-html-attributes/#examples-of-bad-html-attribute-escaping",
            "text": "An example of incorrect HTML attribute escaping:  <?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n' onmouseover='alert(/ZF2!/);\nINPUT;\n\n/**\n * NOTE: This is equivalent to using htmlspecialchars($input, ENT_COMPAT)\n */\n$output = htmlspecialchars($input);\n?>\n<html>\n<head>\n    <title>Single Quoted Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title='' onmouseover='alert(/ZF2!/);'>\n        ?>\n        <span title='<?= $output ?>'>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>  In the above example, the default  ENT_COMPAT  flag is being used, which does\nnot escape single quotes, thus resulting in an alert box popping up when the onmouseover  event happens on the  span  element.  Another example of incorrect HTML attribute escaping can happen when unquoted\nattributes are used (which is, by the way, perfectly valid HTML5):  <?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nfaketitle onmouseover=alert(/ZF2!/);\nINPUT;\n\n// Tough luck using proper flags when the title attribute is unquoted!\n$output = htmlspecialchars($input, ENT_QUOTES);\n?>\n<html>\n<head>\n    <title>Quoteless Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title=faketitle onmouseover=alert(/ZF2!/);>\n        ?>\n        <span title=<?= $output ?>>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>  The above example shows how it is easy to break out from unquoted attributes in\nHTML5.",
            "title": "Examples of Bad HTML Attribute Escaping"
        },
        {
            "location": "/escaping-html-attributes/#example-of-good-html-attribute-escaping",
            "text": "Both of the previous examples can be avoided by simply using the escapeHtmlAttr()  method:  <?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nfaketitle onmouseover=alert(/ZF2!/);\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeHtmlAttr($input);\n?>\n<html>\n<head>\n    <title>Quoteless Attribute</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n</head>\n<body>\n    <div>\n        <?php\n        // the span tag will look like:\n        // <span title=faketitle&#x20;onmouseover&#x3D;alert&#x28;&#x2F;ZF2&#x21;&#x2F;&#x29;&#x3B;>\n        ?>\n        <span title=<?= $output ?>>\n            What framework are you using?\n        </span>\n    </div>\n</body>\n</html>  In the above example, the malicious input from the attacker becomes completely\nharmless as we used proper HTML attribute escaping!",
            "title": "Example of Good HTML Attribute Escaping"
        },
        {
            "location": "/escaping-javascript/",
            "text": "Escaping Javascript\n\n\nJavascript string literals in HTML are subject to significant restrictions due\nto the potential for unquoted attributes and uncertainty as to whether\nJavascript will be viewed as being \nCDATA\n or \nPCDATA\n by the browser. To\neliminate any possible XSS vulnerabilities, Javascript escaping for HTML extends\nthe escaping rules of both ECMAScript and JSON to include any potentially\ndangerous character. Very similar to HTML attribute value escaping, this means\nescaping everything except basic alphanumeric characters and the comma, period,\nand underscore characters as hexadecimal or unicode escapes.\n\n\nJavascript escaping applies to all literal strings and digits. It is not\npossible to safely escape other Javascript markup.\n\n\nTo escape data in the \nJavascript context\n, use \nZend\\Escaper\\Escaper\n's\n\nescapeJs()\n method. An extended set of characters are escaped beyond\nECMAScript's rules for Javascript literal string escaping in order to prevent\nmisinterpretation of Javascript as HTML leading to the injection of special\ncharacters and entities.\n\n\nExample of Bad Javascript Escaping\n\n\nAn example of incorrect Javascript escaping:\n\n\n<?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\nINPUT;\n\n$output = json_encode($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped Entities</title>\n    <meta charset=\"UTF-8\"/>\n    <script type=\"text/javascript\">\n        <?php\n        // this will result in\n        // var foo = \"bar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\";\n        ?>\n        var foo = <?= $output ?>;\n    </script>\n</head>\n<body>\n    <p>json_encode() is not good for escaping javascript!</p>\n</body>\n</html>\n\n\n\nThe above example will show an alert popup box as soon as the page is loaded,\nbecause the data is not properly escaped for the Javascript context.\n\n\nExample of Good Javascript Escaping\n\n\nBy using the \nescapeJs()\n method in the Javascript context, such attacks can be\nprevented:\n\n\n<?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeJs($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Escaped Entities</title>\n    <meta charset=\"UTF-8\"/>\n    <script type=\"text/javascript\">\n        <?php\n        // this will look like\n        // var foo =\nbar\\x26quot\\x3B\\x3B\\x20alert\\x28\\x26quot\\x3BMeow\\x21\\x26quot\\x3B\\x29\\x3B\\x20var\\x20xss\\x3D\\x26quot\\x3Btrue;\n        ?>\n        var foo = <?= $output ?>;\n    </script>\n</head>\n<body>\n    <p>Zend\\Escaper\\Escaper::escapeJs() is good for escaping javascript!</p>\n</body>\n</html>\n\n\n\nIn the above example, the Javascript parser will most likely report a\n\nSyntaxError\n, but at least the targeted application remains safe from such\nattacks.",
            "title": "Escaping Javascript"
        },
        {
            "location": "/escaping-javascript/#escaping-javascript",
            "text": "Javascript string literals in HTML are subject to significant restrictions due\nto the potential for unquoted attributes and uncertainty as to whether\nJavascript will be viewed as being  CDATA  or  PCDATA  by the browser. To\neliminate any possible XSS vulnerabilities, Javascript escaping for HTML extends\nthe escaping rules of both ECMAScript and JSON to include any potentially\ndangerous character. Very similar to HTML attribute value escaping, this means\nescaping everything except basic alphanumeric characters and the comma, period,\nand underscore characters as hexadecimal or unicode escapes.  Javascript escaping applies to all literal strings and digits. It is not\npossible to safely escape other Javascript markup.  To escape data in the  Javascript context , use  Zend\\Escaper\\Escaper 's escapeJs()  method. An extended set of characters are escaped beyond\nECMAScript's rules for Javascript literal string escaping in order to prevent\nmisinterpretation of Javascript as HTML leading to the injection of special\ncharacters and entities.",
            "title": "Escaping Javascript"
        },
        {
            "location": "/escaping-javascript/#example-of-bad-javascript-escaping",
            "text": "An example of incorrect Javascript escaping:  <?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\nINPUT;\n\n$output = json_encode($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped Entities</title>\n    <meta charset=\"UTF-8\"/>\n    <script type=\"text/javascript\">\n        <?php\n        // this will result in\n        // var foo = \"bar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\";\n        ?>\n        var foo = <?= $output ?>;\n    </script>\n</head>\n<body>\n    <p>json_encode() is not good for escaping javascript!</p>\n</body>\n</html>  The above example will show an alert popup box as soon as the page is loaded,\nbecause the data is not properly escaped for the Javascript context.",
            "title": "Example of Bad Javascript Escaping"
        },
        {
            "location": "/escaping-javascript/#example-of-good-javascript-escaping",
            "text": "By using the  escapeJs()  method in the Javascript context, such attacks can be\nprevented:  <?php header('Content-Type: text/html; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbar&quot;; alert(&quot;Meow!&quot;); var xss=&quot;true\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeJs($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Escaped Entities</title>\n    <meta charset=\"UTF-8\"/>\n    <script type=\"text/javascript\">\n        <?php\n        // this will look like\n        // var foo =\nbar\\x26quot\\x3B\\x3B\\x20alert\\x28\\x26quot\\x3BMeow\\x21\\x26quot\\x3B\\x29\\x3B\\x20var\\x20xss\\x3D\\x26quot\\x3Btrue;\n        ?>\n        var foo = <?= $output ?>;\n    </script>\n</head>\n<body>\n    <p>Zend\\Escaper\\Escaper::escapeJs() is good for escaping javascript!</p>\n</body>\n</html>  In the above example, the Javascript parser will most likely report a SyntaxError , but at least the targeted application remains safe from such\nattacks.",
            "title": "Example of Good Javascript Escaping"
        },
        {
            "location": "/escaping-css/",
            "text": "Escaping Cascading Style Sheets\n\n\nCSS is similar to \nescaping Javascript\n.  CSS escaping\nexcludes only basic alphanumeric characters and escapes all other characters\ninto valid CSS hexadecimal escapes.\n\n\nExample of Bad CSS Escaping\n\n\nIn most cases developers forget to escape CSS completely:\n\n\n<?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbody {\n    background-image: url('http://example.com/foo.jpg?</style><script>alert(1)</script>');\n}\nINPUT;\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped CSS</title>\n    <meta charset=\"UTF-8\"/>\n    <style>\n    <?= $input ?>\n    </style>\n</head>\n<body>\n    <p>User controlled CSS needs to be properly escaped!</p>\n</body>\n</html>\n\n\n\nIn the above example, by failing to escape the user provided CSS, an attacker\ncan execute an XSS attack fairly easily.\n\n\nExample of Good CSS Escaping\n\n\nBy using \nescapeCss()\n method in the CSS context, such attacks can be prevented:\n\n\n<?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbody {\n    background-image: url('http://example.com/foo.jpg?</style><script>alert(1)</script>');\n}\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeCss($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Escaped CSS</title>\n    <meta charset=\"UTF-8\"/>\n    <style>\n    <?php\n    // output will look something like\n    // body\\20 \\7B \\A \\20 \\20 \\20 \\20 background\\2D image\\3A \\20 url\\28 ...\n    echo $output;\n    ?>\n    </style>\n</head>\n<body>\n    <p>User controlled CSS needs to be properly escaped!</p>\n</body>\n</html>\n\n\n\nBy properly escaping user controlled CSS, we can prevent XSS attacks in our web\napplications.",
            "title": "Escaping CSS"
        },
        {
            "location": "/escaping-css/#escaping-cascading-style-sheets",
            "text": "CSS is similar to  escaping Javascript .  CSS escaping\nexcludes only basic alphanumeric characters and escapes all other characters\ninto valid CSS hexadecimal escapes.",
            "title": "Escaping Cascading Style Sheets"
        },
        {
            "location": "/escaping-css/#example-of-bad-css-escaping",
            "text": "In most cases developers forget to escape CSS completely:  <?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbody {\n    background-image: url('http://example.com/foo.jpg?</style><script>alert(1)</script>');\n}\nINPUT;\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped CSS</title>\n    <meta charset=\"UTF-8\"/>\n    <style>\n    <?= $input ?>\n    </style>\n</head>\n<body>\n    <p>User controlled CSS needs to be properly escaped!</p>\n</body>\n</html>  In the above example, by failing to escape the user provided CSS, an attacker\ncan execute an XSS attack fairly easily.",
            "title": "Example of Bad CSS Escaping"
        },
        {
            "location": "/escaping-css/#example-of-good-css-escaping",
            "text": "By using  escapeCss()  method in the CSS context, such attacks can be prevented:  <?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\nbody {\n    background-image: url('http://example.com/foo.jpg?</style><script>alert(1)</script>');\n}\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeCss($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Escaped CSS</title>\n    <meta charset=\"UTF-8\"/>\n    <style>\n    <?php\n    // output will look something like\n    // body\\20 \\7B \\A \\20 \\20 \\20 \\20 background\\2D image\\3A \\20 url\\28 ...\n    echo $output;\n    ?>\n    </style>\n</head>\n<body>\n    <p>User controlled CSS needs to be properly escaped!</p>\n</body>\n</html>  By properly escaping user controlled CSS, we can prevent XSS attacks in our web\napplications.",
            "title": "Example of Good CSS Escaping"
        },
        {
            "location": "/escaping-url/",
            "text": "Escaping URLs\n\n\nThis method is basically an alias for PHP's \nrawurlencode()\n which has applied\nRFC 3986 since PHP 5.3. It is included primarily for consistency.\n\n\nURL escaping applies to data being inserted into a URL and not to the whole URL\nitself.\n\n\nExample of Bad URL Escaping\n\n\nXSS attacks are easy if data inserted into URLs is not escaped properly:\n\n\n<?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n\" onmouseover=\"alert('zf2')\nINPUT;\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped URL data</title>\n    <meta charset=\"UTF-8\"/>\n</head>\n<body>\n    <a href=\"http://example.com/?name=<?= $input ?>\">Click here!</a>\n</body>\n</html>\n\n\n\nExample of Good URL Escaping\n\n\nBy properly escaping data in URLs by using \nescapeUrl()\n, we can prevent XSS\nattacks:\n\n\n<?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n\" onmouseover=\"alert('zf2')\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeUrl($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped URL data</title>\n    <meta charset=\"UTF-8\"/>\n</head>\n<body>\n    <a href=\"http://example.com/?name=<?= $output ?>\">Click here!</a>\n</body>\n</html>",
            "title": "Escaping URLs"
        },
        {
            "location": "/escaping-url/#escaping-urls",
            "text": "This method is basically an alias for PHP's  rawurlencode()  which has applied\nRFC 3986 since PHP 5.3. It is included primarily for consistency.  URL escaping applies to data being inserted into a URL and not to the whole URL\nitself.",
            "title": "Escaping URLs"
        },
        {
            "location": "/escaping-url/#example-of-bad-url-escaping",
            "text": "XSS attacks are easy if data inserted into URLs is not escaped properly:  <?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n\" onmouseover=\"alert('zf2')\nINPUT;\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped URL data</title>\n    <meta charset=\"UTF-8\"/>\n</head>\n<body>\n    <a href=\"http://example.com/?name=<?= $input ?>\">Click here!</a>\n</body>\n</html>",
            "title": "Example of Bad URL Escaping"
        },
        {
            "location": "/escaping-url/#example-of-good-url-escaping",
            "text": "By properly escaping data in URLs by using  escapeUrl() , we can prevent XSS\nattacks:  <?php header('Content-Type: application/xhtml+xml; charset=UTF-8'); ?>\n<!DOCTYPE html>\n<?php\n$input = <<<INPUT\n\" onmouseover=\"alert('zf2')\nINPUT;\n\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n$output = $escaper->escapeUrl($input);\n?>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title>Unescaped URL data</title>\n    <meta charset=\"UTF-8\"/>\n</head>\n<body>\n    <a href=\"http://example.com/?name=<?= $output ?>\">Click here!</a>\n</body>\n</html>",
            "title": "Example of Good URL Escaping"
        }
    ]
}